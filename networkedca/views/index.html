<!doctype html>
<html>
  <head>
    <style>
    body {
      background-color: black;
      color: white;
    }

    .left {
      float: left;
      width: 25%;
    } 

    .left h2 {
      text-align: center;
    }

    .canvases-wrapper {
      position: relative;
      float: right;
    } .canvases-wrapper canvas {
      } .canvases-wrapper canvas#drag-and-drop-canvas {
          position: absolute;
          left: 0;
          top: 0;
          background-color: transparent;
        }
    
    footer {
      position: fixed;
      width: 100%;
      bottom: 0;
      left: 0;  
    }
    .drag-and-drop-container {
      background-color: gray;
      height: 40px;
      width: 100%;
    } 
    .drag-and-drop-container ul {
      list-style-type: none;
    } .drag-and-drop-container ul > li {
        display: inline-block;
        width: 10%;
      }
    </style>
  </head>
  <body>
    <div class="left">
      <h2>Everyone</h2>
      <h2>Plays</h2>
      <h2>Life</h2>
      <hr/>
      <h2> What is Conway's Game Of Life? </h2>
      <p>A 2d cellular automata model.
      <hr />
      <h2> Rules </h2>
      <p>Each cell is the center of its own 3x3 neighborhood.  Whether a cell lives or dies depends on the amount of live neighbors.</p>
      <span>A cell will die in the next generation if...</span>
      <ul>
        <li>It has less than two live neighbors, due to underpopulation.</li>
        <li>It has more than three live neighbors, due to overpopulation.</li>
      </ul>
      <span>A cell will live to the next generation if...</span>
      <ul>
        <li>It has either two or three live neighbors.</li>
      </ul>
      <span>Finally, a cell will be revived in the next generation if...</span>
      <ul>
        <li>It has exactly three live neighbors, due to reproduction.</li>
      </ul>
      <hr />
      <h2> How To Play </h2>
      <p>Click on the cell whose state you want to switch.  The cell will change state in the next generation.</p>
    </div>

    <div class="canvases-wrapper">
      <canvas id="canvas" width="1000px" height="1000px"></canvas>
      <canvas id="drag-and-drop-canvas" width="0px" height="0px"></canvas>
    </div>

    <footer>
      <!-- drag and drop interface -->
      <div class="drag-and-drop-container">
        <ul>
          <li data-ca-shape="r-pentomino">R-pentomino</li>
          <li data-ca-shape="square">Square</li>
          <li data-ca-shape="something">Something</li>
        </ul>
      </div>
    </footer>
  </body>

  <script src="https://code.jquery.com/jquery-2.1.3.min.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <script>
  </script>
  <script>
  var predefinedShapes = {
    'r-pentomino': [ [0, 1, 1],
                     [1, 1, 0],
                     [0, 1, 0] ],

    'square': [ [1, 1, 1],
                [1, 1, 1],
                [1, 1, 1] ],
    
    'something': [ [1,0],
                   [0, 1],
                   [1, 0] ]

  };

  var CAPredefinedShapes = (function(predefinedShapes){
    // returns selected shape given a name.
    this.getCurrentSelected = function(name) {
      return predefinedShapes[name];
    };

    // iterates over a given shape.
    // uses: drag & drop hover effect,
    //       drag & drop placement
    this.iterateOverShape = function(shape, cb) {
      var shapeHeight = shape.length,
          i = 0;

      for ( ; i < shapeHeight; ++i) {
        var shapeWidth = shape[i].length,
            j = 0;
        for ( ; j < shapeWidth; ++j) {
          // send the cell at index and its coordinates
          cb(shape[i][j], [i, j]);
        }
      }
    };

    return this;
  })(predefinedShapes);

  // helper function to initialize some custom canvas functions
  var CanvasExtensions = (function() {
    // helper function to calculate position of a click
    HTMLCanvasElement.prototype.getMouseCoords = function(event){
      var totalOffsetX = 0;
      var totalOffsetY = 0;
      var canvasX = 0;
      var canvasY = 0;
      var currentElement = this;

      do{
        totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
        totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
      }
      while(currentElement = currentElement.offsetParent)

      canvasX = event.pageX - totalOffsetX;
      canvasY = event.pageY - totalOffsetY;

      return [canvasX, canvasY];
    };

    HTMLCanvasElement.prototype.snapToGrid = function(coords, colWidth, rowHeight) {
        coords[0] -= (coords[0] % colWidth);
        coords[1] -= (coords[1] % rowHeight);

        return coords;
    };

    HTMLCanvasElement.prototype.getSnappedCoordinates = function(event, colWidth, rowHeight) {
      var coords = this.getMouseCoords(event);
      return this.snapToGrid(coords, colWidth, rowHeight);
    };
  })();
  
  var User = function() {
    this.isDragging = false;
    this.currentShape = [[]];
  };

  $(document).ready(function() {
    var user = new User;

    // drag and drop 
    $('.drag-and-drop-container ul li').mousedown(function() {
      var shape = CAPredefinedShapes
                  .getCurrentSelected($(this).attr('data-ca-shape'));
      user.isDragging = true;
      user.currentShape = shape;
    }).mouseup(function() {
      user.isDragging = false;
    });

    // initialize socket.io
    var socket = io();
        canvas = document.getElementById('canvas'),
        context = canvas.getContext('2d'),
        dragAndDropCanvas = document.getElementById('drag-and-drop-canvas'),
        dragAndDropContext = dragAndDropCanvas.getContext('2d'),
        canvasWidth = canvas.width,
        canvasHeight = canvas.height,
        graph = undefined;

    // send event to paint canvas
    dragAndDropCanvas.onmousemove = function(e) {
      canvas.onmousemove(e);
    };

    // reset drag and drop canvas, and send event to paint canvas
    dragAndDropCanvas.onmouseup = function(e) {
      $(dragAndDropCanvas).css({
        'left': 0,
        'top': 0,
      });
      
      dragAndDropCanvas.width = 0;
      dragAndDropCanvas.height = 0;

      canvas.onmouseup(e);
    };

    // when user is dragging a shape onto canvas, draw a shadow
    canvas.onmousemove = function(e) {
      if (user.isDragging) {
        var shape = user.currentShape,
            coords = canvas.getSnappedCoordinates(e, graph.mColumnWidth, graph.mRowHeight),
            cellWidth = graph.mColumnWidth,
            cellHeight = graph.mRowHeight;
            shapePixelHeight = shape.length * cellWidth,
            shapePixelWidth = shape[0].length * cellHeight;

        // 1) move drag and drop canvas to coords with appropriate width & height
        $(dragAndDropCanvas).css({
          'left': coords[0],
          'top': coords[1],
        });

        dragAndDropCanvas.width = shapePixelWidth;
        dragAndDropCanvas.height = shapePixelHeight;

        // Draw a 'floating' drag and drop 
        CAPredefinedShapes.iterateOverShape(shape, function(cell, cellCoords) {
          var i = cellCoords[0],
              j = cellCoords[1];

          if (cell == 1) {
            dragAndDropContext.fillStyle = '#00ff00';
          }
          else {
            dragAndDropContext.fillStyle = 'rgba(255, 255, 255, .5)';
          }

          dragAndDropContext.fillRect(j * cellWidth, i * cellHeight, cellWidth, cellHeight);
        });
      }
    };

    // when user clicks on canvas, snap coords to grid and send 
    canvas.onmouseup = function(e) {
      var coords = canvas.getSnappedCoordinates(e, graph.mColumnWidth, graph.mRowHeight),
          cellWidth = graph.mColumnWidth,
          cellHeight = graph.mRowHeight;
          
      if (!user.isDragging) {
        var canvasX = coords[0],
            canvasY = coords[1];
         
        context.fillStyle = '#00ff00';
        context.fillRect(canvasX, canvasY, cellWidth, cellHeight);
        socket.emit('send coords', [canvasX, canvasY]);
      }

      // if user was dragging, place a shape there 
      else {
        // place a life pattern at a snapped to grid point
        // shape is an NxM array
        var shape = user.currentShape;
        
        // iterate through the life pattern and fill accordingly
        CAPredefinedShapes.iterateOverShape(shape, function(cell, cellCoords) {
          if (cell == 1) {
            var i = cellCoords[0],
                j = cellCoords[1],
                x = coords[0] + (j * cellWidth),
                y = coords[1] + (i * cellHeight);

            context.fillStyle = '#00ff00';
            context.fillRect(x, y, cellWidth, cellHeight);
            socket.emit('send coords', [x, y]);
          }
        });
        
        // reset dragging marker
        user.isDragging = false;
      }
    };

    var drawGraph = function() {
      context.beginPath();
      context.strokeStyle = '#fff';
      for (var x = 0; x <= graph.mWidth; x += graph.mColumnWidth) {
        context.moveTo(x, 0);
        context.lineTo(x, graph.mHeight);
      }

      for (var y = 0; y <= graph.mHeight; y += graph.mRowHeight) {
        context.moveTo(0, y);
        context.lineTo(graph.mWidth, y);
      }

      context.stroke();
    };
    
    // Get graph info on initial connection
    socket.on('graph dimensions', function(g, id) {
      if (socket.id !== id) return;
      graph = g;
      drawGraph();
    });

    // redraw canvas
    socket.on('live cells', function(cells) {
      window.requestAnimationFrame(function(timestamp) {
        // clear canvas
        context.fillStyle = '#000';
        context.fillRect(0, 0, canvas.width, canvas.height);

        // draw graph
        drawGraph();

        // draw cells
        context.fillStyle = '#fff';
        var len = cells.length,
            i = 0;
        // 'cells' is an array of [x, y]
        for ( ; i < len; ++i) {
          var coords = cells[i],
              x = coords[0] * graph.mColumnWidth,
              y = coords[1] * graph.mRowHeight,
              cellWidth = graph.mColumnWidth,
              cellHeight = graph.mRowHeight;
          context.fillRect(x, y, cellWidth, cellHeight);
        }
      });
    });
  });
  </script>
</html>
